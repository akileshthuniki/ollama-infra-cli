name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  IMAGE_NAME: ollama-api

jobs:
  test-analyzer:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          cd devops-analyzer
          pip install -r requirements.txt

      - name: Test analyzer
        run: |
          cd devops-analyzer
          python devops-analyzer.py url https://google.com --no-ai
          python devops-analyzer.py --help

  # Test Application
  test-app:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          cd src
          pip install -r requirements.txt

      - name: Run tests
        run: |
          cd src
          python -m pytest tests/ || echo "No tests found, continuing..."
          python app.py &
          sleep 5
          curl -f http://localhost:8080/health || true
          pkill -f "python app.py"

  # Build and Push Docker Image
  build-and-push:
    needs: [test-analyzer, test-app]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          TAG=${{ github.sha }}
          IMAGE_URI=${ECR_REGISTRY}/${IMAGE_NAME}:${TAG}
          
          # Build image
          docker build -t ${IMAGE_URI} -f docker/Dockerfile.api .
          
          # Push image
          docker push ${IMAGE_URI}
          
          # Also push latest tag
          docker tag ${IMAGE_URI} ${ECR_REGISTRY}/${IMAGE_NAME}:latest
          docker push ${ECR_REGISTRY}/${IMAGE_NAME}:latest
          
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV

  # Deploy to Staging
  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.0"

      - name: Deploy to Staging
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: |
          cd infra/environments/staging
          
          # Initialize Terraform
          terraform init
          
          # Plan deployment
          terraform plan -out=tfplan -var "image_uri=${IMAGE_URI}"
          
          # Apply deployment
          terraform apply -auto-approve tfplan
          
          # Get ALB URL for health check
          ALB_URL=$(terraform output -raw alb_url)
          echo "ALB_URL=${ALB_URL}" >> $GITHUB_ENV

      - name: Health Check
        env:
          ALB_URL: ${{ env.ALB_URL }}
        run: |
          echo "Checking health of ${ALB_URL}"
          
          # Wait for deployment to be ready
          for i in {1..30}; do
            if curl -f ${ALB_URL}/health; then
              echo "‚úÖ Health check passed"
              break
            fi
            echo "‚è≥ Waiting for service to be ready... ($i/30)"
            sleep 10
          done

      - name: Run DevOps Analyzer
        env:
          ALB_URL: ${{ env.ALB_URL }}
        run: |
          cd devops-analyzer
          pip install -r requirements.txt
          
          # Run post-deployment analysis
          python devops-analyzer.py url ${ALB_URL} --question "Is the deployment successful?" --output deployment_analysis.md
          
          # Run infrastructure health check
          python devops-analyzer.py infrastructure --type health --cluster ollama-cluster-staging --output health_check.md
          
          echo "üìä Analysis completed"
          cat deployment_analysis.md
          cat health_check.md

  # Deploy to Production (Manual)
  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.0"

      - name: Deploy to Production
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: |
          cd infra/environments/production
          
          # Initialize Terraform
          terraform init
          
          # Plan deployment
          terraform plan -out=tfplan -var "image_uri=${IMAGE_URI}"
          
          # Apply deployment
          terraform apply -auto-approve tfplan
          
          # Get ALB URL
          ALB_URL=$(terraform output -raw alb_url)
          echo "ALB_URL=${ALB_URL}" >> $GITHUB_ENV

      - name: Production Health Check
        env:
          ALB_URL: ${{ env.ALB_URL }}
        run: |
          echo "üîç Checking production health at ${ALB_URL}"
          
          # Wait for deployment
          for i in {1..60}; do
            if curl -f ${ALB_URL}/health; then
              echo "‚úÖ Production health check passed"
              break
            fi
            echo "‚è≥ Production deployment in progress... ($i/60)"
            sleep 10
          done

      - name: Production Analysis
        env:
          ALB_URL: ${{ env.ALB_URL }}
        run: |
          cd devops-analyzer
          
          # Final production analysis
          python devops-analyzer.py url ${ALB_URL} --question "Verify production deployment is successful" --output production_analysis.md
          
          echo "üéâ Production deployment completed"
          cat production_analysis.md

  # Cleanup Old Images
  cleanup:
    needs: [deploy-staging, deploy-production]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Cleanup old ECR images
        run: |
          # Keep only last 10 images
          aws ecr describe-images --repository-name ${{ env.IMAGE_NAME }} --query 'imageDetails[*].imageTags' --output text | \
          tr '\t' '\n' | grep -E '^[a-f0-9]{40}$' | sort -r | tail -n +11 | \
          while read tag; do
            if [ -n "$tag" ]; then
              echo "Deleting old image: $tag"
              aws ecr batch-delete-image --repository-name ${{ env.IMAGE_NAME }} --image-ids imageTag=$tag
            fi
          done
